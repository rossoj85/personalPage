'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _dirtyChai = require('dirty-chai');

var _dirtyChai2 = _interopRequireDefault(_dirtyChai);

var _sinonChai = require('sinon-chai');

var _sinonChai2 = _interopRequireDefault(_sinonChai);

var _enzyme = require('enzyme');

var _withTransition = require('./withTransition');

var _withTransition2 = _interopRequireDefault(_withTransition);

var _activeState = require('./activeState');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_chai2.default.use(_dirtyChai2.default).use(_sinonChai2.default);

describe('withTransition', function () {
  var props = void 0,
      context = void 0,
      transitionConfig = void 0,
      BaseComponent = void 0,
      WrappedComponent = void 0;

  beforeEach(function () {
    var route = {};

    var TransitionGroup = function TransitionGroup(_ref) {
      var children = _ref.children;
      return _react2.default.createElement(
        'div',
        { className: 'transition-group' },
        children
      );
    };

    TransitionGroup.propTypes = { children: _react.PropTypes.node };

    props = {
      location: {
        key: 'first',
        pathname: '/first'
      },
      route: route,
      routes: [route]
    };

    context = {
      transitionRouter: {
        getLocationIndex: _sinon2.default.stub()
      }
    };

    BaseComponent = function BaseComponent() {
      return null;
    };
    transitionConfig = {
      TransitionGroup: TransitionGroup,
      onShow: _sinon2.default.stub(),
      onDismiss: _sinon2.default.stub(),
      defaultTransition: { transition: 'my-default' }
    };

    WrappedComponent = (0, _withTransition2.default)(BaseComponent, transitionConfig);
  });

  describe('first render', function () {
    it('should use default transition', function () {
      var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(WrappedComponent, props), { context: context });
      (0, _chai.expect)(wrapper.props(), 'component should get parent properties').to.have.property('location', props.location);

      (0, _chai.expect)(wrapper.props(), 'component should get parent properties').to.have.property('route', props.route);

      (0, _chai.expect)(wrapper.props(), 'component should get parent properties').to.have.property('routes', props.routes);

      (0, _chai.expect)(wrapper.children().props(), 'transition group should get default transition').to.have.property('transition', 'my-default');
    });
  });

  describe('with state disabled', function () {
    beforeEach(function () {
      (0, _activeState.disableTransitions)();
    });
    afterEach(function () {
      (0, _activeState.enableTransitions)();
    });
    it('should render the transition group with instant transition', function () {
      var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(WrappedComponent, props), { context: context });
      var nextLocation = { key: 'second', pathname: '/second' };
      var nextProps = _extends({}, props, { location: nextLocation });
      wrapper.setProps(nextProps);
      (0, _chai.expect)(wrapper.children().props()).to.have.property('transition', 'instant');
    });
  });

  describe('after show', function () {
    it('should call hook if available', function () {
      var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(WrappedComponent, props), { context: context });

      transitionConfig.onShow.callsArgWith(2, {
        transition: 'show'
      });

      context.transitionRouter.getLocationIndex.withArgs(props.location).returns(0);

      var nextLocation = {
        key: 'second',
        pathname: '/second'
      };

      var nextProps = _extends({}, props, {
        location: nextLocation
      });

      context.transitionRouter.getLocationIndex.withArgs(nextLocation).returns(1);

      wrapper.setProps(nextProps);

      (0, _chai.expect)(transitionConfig.onShow, 'onShow hook should be called once').to.be.calledOnce();

      (0, _chai.expect)(transitionConfig.onShow, 'onShow hook should be called with instance as this').to.be.calledOn(wrapper.instance());

      (0, _chai.expect)(transitionConfig.onShow, 'onShow hook should be called with props').to.be.calledWith(props, nextProps);

      (0, _chai.expect)(wrapper.children().props(), 'transition group should get "show" transition').to.have.property('transition', 'show');
    });

    it('should use transition state', function () {
      var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(WrappedComponent, props), { context: context });

      context.transitionRouter.getLocationIndex.withArgs(props.location).returns(1);

      var nextLocation = {
        key: 'second',
        pathname: '/second',
        state: {
          showTransition: {
            transition: 'show-from-state'
          }
        }
      };

      var nextProps = _extends({}, props, {
        location: nextLocation
      });

      context.transitionRouter.getLocationIndex.withArgs(nextLocation).returns(2);

      wrapper.setProps(nextProps);

      (0, _chai.expect)(wrapper.children().props(), 'transition group should get "show-from-state" transition').to.have.property('transition', 'show-from-state');
    });
  });

  describe('after dismiss', function () {
    it('should call hook if available', function () {
      var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(WrappedComponent, props), { context: context });

      transitionConfig.onDismiss.callsArgWith(2, {
        transition: 'dismiss'
      });

      context.transitionRouter.getLocationIndex.withArgs(props.location).returns(1);

      var nextLocation = {
        key: 'second',
        pathname: '/second'
      };

      var nextProps = _extends({}, props, {
        location: nextLocation
      });

      context.transitionRouter.getLocationIndex.withArgs(nextLocation).returns(0);

      wrapper.setProps(nextProps);

      (0, _chai.expect)(transitionConfig.onDismiss, 'onDismiss hook should be called once').to.be.calledOnce();

      (0, _chai.expect)(transitionConfig.onDismiss, 'onDismiss hook should be called with instance as this').to.be.calledOn(wrapper.instance());

      (0, _chai.expect)(transitionConfig.onDismiss, 'onDismiss hook should be called with props').to.be.calledWith(props, nextProps);

      (0, _chai.expect)(wrapper.children().props(), 'transition group should get "dismiss" transition').to.have.property('transition', 'dismiss');
    });

    it('should use transition state', function () {
      props.location.state = {
        dismissTransition: {
          transition: 'dismiss-from-state'
        }
      };

      var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(WrappedComponent, props), { context: context });

      context.transitionRouter.getLocationIndex.withArgs(props.location).returns(2);

      var nextLocation = {
        key: 'second',
        pathname: '/second'
      };

      var nextProps = _extends({}, props, {
        location: nextLocation
      });

      context.transitionRouter.getLocationIndex.withArgs(nextLocation).returns(1);

      wrapper.setProps(nextProps);

      (0, _chai.expect)(wrapper.children().props(), 'transition group should get "dismiss-from-state" transition').to.have.property('transition', 'dismiss-from-state');
    });

    it('should use transition state even for multi depth level', function () {
      props.location.state = {
        dismissTransition: {
          transition: 'dismiss-from-state'
        }
      };

      var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(WrappedComponent, props), { context: context });

      context.transitionRouter.getLocationIndex.withArgs(props.location).returns(3);

      var nextLocation = {
        key: 'second',
        pathname: '/second'
      };

      var nextProps = _extends({}, props, {
        location: nextLocation
      });

      context.transitionRouter.getLocationIndex.withArgs(nextLocation).returns(1);

      wrapper.setProps(nextProps);

      (0, _chai.expect)(wrapper.children().props(), 'transition group should get "dismiss-from-state" transition').to.have.property('transition', 'dismiss-from-state');
    });
  });
});