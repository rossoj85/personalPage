'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _sinon = require('sinon');

var _sinonChai = require('sinon-chai');

var _sinonChai2 = _interopRequireDefault(_sinonChai);

var _dirtyChai = require('dirty-chai');

var _dirtyChai2 = _interopRequireDefault(_dirtyChai);

var _jsdom = require('jsdom');

var _TestHelpers = require('../test/TestHelpers');

var _TransitionContext = require('./TransitionContext');

var _TransitionContext2 = _interopRequireDefault(_TransitionContext);

var _HistoryActions = require('./HistoryActions');

var _TransitionActions = require('./TransitionActions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Bootstrap the DOM environment in node
 */

global.document = (0, _jsdom.jsdom)('');
global.window = document.defaultView;

Object.keys(document.defaultView).forEach(function (property) {
  if (typeof global[property] === 'undefined') {
    global[property] = document.defaultView[property];
  }
});

_chai2.default.use(_dirtyChai2.default).use(_sinonChai2.default);

describe('TransitionContext', function () {
  var props = void 0;

  beforeEach(function () {
    props = {
      location: {
        key: 'initial-location',
        state: {
          first: true
        }
      },
      router: {
        go: (0, _sinon.spy)(),
        push: (0, _sinon.spy)(),
        replace: (0, _sinon.spy)()
      },
      transitionConfig: {
        defaultTransition: {
          transition: 'custom'
        }
      }
    };
  });

  describe('#config', function () {
    it('should be exposed in context', function () {
      props.transitionConfig = { foo: 'bar' };

      var _getChildContext = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
          config = _getChildContext.context.transitionRouter.config;

      (0, _chai.expect)(config, 'context.transitionRouter.config should be equal to props.config').to.eql({ foo: 'bar' });
    });
  });

  describe('#getLocationIndex', function () {
    describe('without location', function () {
      it('should return 0', function () {
        var _getChildContext2 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
            getLocationIndex = _getChildContext2.context.transitionRouter.getLocationIndex;

        (0, _chai.expect)(getLocationIndex(), 'context.transitionRouter.getLocationIndex() should return 0').to.equal(0);
      });
    });

    describe('with an unknown location', function () {
      it('should return -1', function () {
        var _getChildContext3 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
            getLocationIndex = _getChildContext3.context.transitionRouter.getLocationIndex;

        (0, _chai.expect)(getLocationIndex({}), 'context.transitionRouter.getLocationIndex() should return -1').to.equal(-1);
      });
    });

    describe('with an history of locations', function () {
      it('should return location position in history', function () {
        var _getChildContext4 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
            wrapper = _getChildContext4.wrapper,
            getLocationIndex = _getChildContext4.context.transitionRouter.getLocationIndex;

        var secondLocation = {
          key: 'second-location',
          action: _HistoryActions.PUSH
        };

        var thirdLocation = {
          key: 'third-location',
          action: _HistoryActions.PUSH
        };

        wrapper.setProps(_extends({}, props, {
          location: secondLocation
        }));

        wrapper.setProps(_extends({}, props, {
          location: thirdLocation
        }));

        (0, _chai.expect)(getLocationIndex(secondLocation), 'context.transitionRouter.getLocationIndex(secondLocation)\n            should return secondLocation index (1)').to.equal(1);

        (0, _chai.expect)(getLocationIndex(thirdLocation), 'context.transitionRouter.getLocationIndex(thirdLocation\n            should return thirdLocation index (2)').to.equal(2);

        (0, _chai.expect)(getLocationIndex(), 'context.transitionRouter.getLocationIndex()\n            should last location index (2)').to.equal(2);
      });
    });
  });

  describe('#dismiss', function () {
    describe('with an history of location', function () {
      it('should call router.go()', function () {
        var _getChildContext5 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
            wrapper = _getChildContext5.wrapper,
            dismiss = _getChildContext5.context.transitionRouter.dismiss;

        var secondLocation = {
          key: 'second-location',
          action: _HistoryActions.PUSH
        };

        wrapper.setProps(_extends({}, props, {
          location: secondLocation
        }));

        dismiss();

        (0, _chai.expect)(props.router.go, 'props.router.go should be called once').to.be.calledOnce();
        _chai.assert.strictEqual(props.router.go.args[0][0], -1);
        _chai.assert.strictEqual(props.router.replace.callCount, 0, 'props.router.replace should not be called');
      });
    });

    describe('without an history of location', function () {
      it('should swap location with action DISMISS', function (done) {
        var _getChildContext6 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
            dismiss = _getChildContext6.context.transitionRouter.dismiss;

        dismiss();

        setTimeout(function () {
          (0, _chai.expect)(props.router.replace, 'props.router.replace should be called once').to.be.calledOnce();
          (0, _chai.expect)(props.router.replace, 'props.router.replace should be called with merged location').to.be.calledWith({
            state: {
              first: true,
              transitionAction: _TransitionActions.DISMISS
            }
          });
          _chai.assert.strictEqual(props.router.go.callCount, 0, 'props.router.go should not be called');
          done();
        }, 0);
      });
    });

    describe('depth option', function () {
      it('should call router.go() and swap location with action DISMISS', function (done) {
        var _getChildContext7 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
            wrapper = _getChildContext7.wrapper,
            dismiss = _getChildContext7.context.transitionRouter.dismiss;

        var secondLocation = {
          key: 'second-location',
          action: _HistoryActions.PUSH
        };

        wrapper.setProps(_extends({}, props, {
          location: secondLocation
        }));

        dismiss('/', {
          depth: 2
        });

        (0, _chai.expect)(props.router.go, 'props.router.go should be called once').to.be.calledOnce();
        _chai.assert.strictEqual(props.router.go.args[0][0], -1);

        setTimeout(function () {
          (0, _chai.expect)(props.router.replace, 'props.router.replace should be called once').to.be.calledOnce();
          (0, _chai.expect)(props.router.replace, 'props.router.replace should be called with merged location').to.be.calledWith({
            action: _HistoryActions.PUSH,
            pathname: '/',
            state: {
              transitionAction: _TransitionActions.DISMISS
            }
          });
          done();
        }, 0);
      });
    });
  });

  describe('#show', function () {
    it('should call router.push()', function () {
      var _getChildContext8 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
          show = _getChildContext8.context.transitionRouter.show;

      show('/new/location');

      (0, _chai.expect)(props.router.push, 'props.router.push should be called once').to.be.calledOnce();
      (0, _chai.expect)(props.router.push, 'props.router.push should be called with location').to.be.calledWith('/new/location');
    });
  });

  describe('#swap', function () {
    it('should merge and replace current location', function () {
      var _getChildContext9 = (0, _TestHelpers.getChildContext)(_TransitionContext2.default, props),
          swap = _getChildContext9.context.transitionRouter.swap;

      swap('/new/location');

      (0, _chai.expect)(props.router.replace, 'props.router.replace should be called once').to.be.calledOnce();
      (0, _chai.expect)(props.router.replace, 'props.router.replace should be called with merged location').to.be.calledWith({
        pathname: '/new/location',
        state: {
          first: true
        }
      });
    });
  });
});